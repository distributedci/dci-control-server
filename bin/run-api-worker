#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from dci.api.v1 import notifications
from dci.worker.umb import send_event_on_umb

from kombu import Connection, Exchange, Queue
from kombu.mixins import ConsumerMixin

import json
import logging
import os
import smtplib
import requests
import sys
import time

try:
    from email.MIMEText import MIMEText
except ImportError:
    from email.mime.text import MIMEText

AMQP_BROKER_URL = os.getenv("AMQP_BROKER_URL", "amqp://guest:guest@rabbitmq:5672//")
LOGGING_LEVEL = logging.INFO


def get_email_configuration():
    configuration = {
        "server": os.getenv("DCI_EMAIL_SERVER", "mail.distributed-ci.io"),
        "port": os.getenv("DCI_EMAIL_SERVER_PORT", 587),
        "account": os.getenv("DCI_EMAIL_ACCOUNT", "no-reply@distributed-ci.io"),
        "password": os.getenv("DCI_EMAIL_PASSWORD"),
    }

    return configuration


def get_dlrn_configuration():
    configuration = {
        "server": os.getenv("DCI_DLRN_SERVER_URL", "trunk.rdoproject.org"),
        "login": os.getenv("DCI_DLRN_LOGIN"),
        "password": os.getenv("DCI_DLRN_PASSWORD"),
    }

    if (
        not configuration["login"]
        or not configuration["password"]
        or not configuration["server"]
    ):
        raise

    return configuration


def dlrn_publish(event):
    dlrn_config = get_dlrn_configuration()

    if event["dlrn"]["commit_branch"] == "master":
        dlrn_config["endpoint"] = "api-centos-master-uc"
    else:
        dlrn_config["endpoint"] = (
            "api-centos-%s" % event["dlrn"]["commit_branch"].split("/")[1]
        )

    payload = {
        "job_id": "DCI-%s" % event["topic_name"],
        "commit_hash": event["dlrn"]["commit_hash"],
        "distro_hash": event["dlrn"]["distro_hash"],
        "url": ("https://www.distributed-ci.io/jobs/%s/jobStates" % event["job_id"]),
        "timestamp": int(time.time()),
        "success": "true" if event["status"] == "success" else "false",
    }

    requests.post(
        "https://%s/%s/api/report_result"
        % (dlrn_config["server"], dlrn_config["endpoint"]),
        auth=(dlrn_config["login"], dlrn_config["password"]),
        data=json.dumps(payload),
        headers={"Content-type": "application/json"},
    )


def _get_smtp_server(email_configuration):
    server = smtplib.SMTP(email_configuration["server"], email_configuration["port"])
    server.starttls()
    if email_configuration["account"] and email_configuration["password"]:
        server.login(email_configuration["account"], email_configuration["password"])
    return server


def send_job_mail(mesg):
    email_configuration = get_email_configuration()
    if email_configuration:
        subject = "[DCI Status][%s][%s][%s]" % (
            mesg["topic_name"],
            mesg["remoteci_name"],
            mesg["status"],
        )
        message = notifications.format_job_mail_message(mesg)
        email = MIMEText(message)
        email["From"] = (
            "Distributed-CI Notification <%s>" % email_configuration["account"]
        )
        email["subject"] = subject
        email["DCI-remoteci"] = mesg["remoteci_id"]
        email["DCI-topic"] = mesg["topic_id"]

        server = _get_smtp_server(email_configuration)
        for contact in mesg["emails"]:
            # email.message are not classic dict, a new affectation does
            # not overwrite the previous one.
            del email["To"]
            email["To"] = contact
            server.sendmail(email["From"], email["To"], email.as_string())
        server.quit()


def send_component_mail(event):
    email_configuration = get_email_configuration()
    if email_configuration:
        subject = "[DCI Status][%s][%s][%s]" % (
            event["topic_name"],
            event["component_name"],
            event["status"],
        )
        message = notifications.format_component_mail_message(event)
        email = MIMEText(message)
        email["From"] = (
            "Distributed-CI Notification <%s>" % email_configuration["account"]
        )
        email["subject"] = subject

        server = _get_smtp_server(email_configuration)
        for contact in event["emails"]:
            # email.message are not classic dict, a new affectation does
            # not overwrite the previous one.
            del email["To"]
            email["To"] = contact
            server.sendmail(email["From"], email["To"], email.as_string())
        server.quit()


def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
    )

    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(LOGGING_LEVEL)
    console_handler.setFormatter(formatter)

    root_logger = logging.getLogger()
    root_logger.setLevel(LOGGING_LEVEL)
    root_logger.handlers.clear()
    root_logger.addHandler(console_handler)

    kombu_logger = logging.getLogger("kombu")
    kombu_logger.setLevel(LOGGING_LEVEL)
    kombu_logger.handlers.clear()
    kombu_logger.addHandler(console_handler)

    kombu_transport_logger = logging.getLogger("kombu.transport")
    kombu_transport_logger.setLevel(LOGGING_LEVEL)
    kombu_transport_logger.handlers.clear()
    kombu_transport_logger.addHandler(console_handler)


class Worker(ConsumerMixin):
    def __init__(self, connection, queues):
        self.connection = connection
        self.queues = queues

    def get_consumers(self, Consumer, channel):
        return [Consumer(queues=self.queues,
                         callbacks=[self.on_message])]

    def on_message(self, body, message):
        try:
            event = body["event"]
            logging.info(f"Worker received event: '{event}'")
            if event == "notification":
                send_job_mail(body)
            elif event == "component_notification":
                send_component_mail(body)
            elif event == "dlrn_publish":
                dlrn_publish(body)
            elif event == "job_finished":
                send_event_on_umb(body)
            logging.info("Worker processed successfully the event.")
        except Exception as e:
            logging.exception(msg=f"An error has occurred when processing the event: {str(e)}")
        message.ack()


if __name__ == '__main__':

    setup_logging()

    exchange_name = "dci.controlserver.exchange"
    exchange_type = "direct"
    queue_name = "dci.controlserver.queue"
    routing_key = "dci.controlserver.events"

    exchange = Exchange(exchange_name, type=exchange_type)
    queues = [Queue(queue_name, exchange, routing_key=routing_key)]

    logging.info("worker waiting for messages")
    logging.info(f"exchange: {exchange_name}, type: {exchange_type}")
    logging.info(f"queue: {queue_name}, routing_key: {routing_key}")

    with Connection(AMQP_BROKER_URL, heartbeat=4) as conn:
            worker = Worker(conn, queues)
            worker.run()
